# Java
1. [JVM](##-1-JVM)
2. [Garbage Collection](##-2-Garbage-Collection)

</br>

## 1 JVM

### 1.1 JVM 이란?
Java Virtual Machnie의 약자이다. 가상 머신(Virtual Machine)은 프로그램을 실행하기 위해 물리적 머신(컴퓨터)과 유사한 머신을 소프트웨어로 구현한 것이다. JVM은 Java와 운영체제 사이에서 중개자 역할을 수행하며, Java가 모든 종류의 운영체제에서 동작이 가능하도록 한다.

- 스택 기반의 가상 머신  
  > 인텔 x86 아키텍처 같은 하드웨어는 레지스터 기반으로 동작하지만, JVM은 스택 기반으로 동작한다.
- 심볼릭 레퍼런스  
  > 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.
  - 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장  
  > C/C++ 등의 전통적인 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.
- Garbage Collection  
  > 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 GC에 의해 자동으로 파괴된다.

### 1.2 Java 프로그램 실행과정
자바로 작성한 코드는 다음의 과정을 통해 수행된다.

<pre>
- JVM은 운영체제로부터 필요한 메모리를 할당받는다.
- 자바 컴파일러(javac)가 소스코드(.java)를 읽고 바이트코드(.class)로 변환한다.
- 클래스 로더(Class Loader)가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드한다.
- 실행 엔진(Execution Engine)이 바이트코드를 실행한다.
- 바이트코드 명령어를 하나씩 읽어서 해석하고 실행한다.
</pre>

### 1.3 JVM 구성
- 클래스 로더(Class Loader)  
  > 자바는 동적 로드, 즉 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다.
- 런타임 데이터 영역(Runtime Data Area)  
  > 런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 6개의 영역으로 나눌 수 있다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area), 런타임 상수 풀(Runtime Constant Pool)은 모든 스레드가 공유해서 사용한다.
- 실행 엔진(Execution Engine)  
  > 클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다. 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다.

</br>

## 2 Garbage Collection

### 2.1 Garbage Collection이란?
Java는 프로그램 코드에서 메모리를 명시적으로 지정하여 해제하지 않는다. 개발자가 메모리를 해제하지 않기 때문에 가비지 컬렉터(Garbage Collector)가 더 이상 필요 없는 객체를 찾아 지우는 작업을 한다.

<pre>
- 힙(heap) 내의 객체 중에서 가비지(garbage)를 찾아낸다.
- 찾아낸 가비지를 처리해서 힙의 메모리를 회수한다.
</pre>

### 2.2 Reachability
GC는 객체가 가비지인지 판별하기 위해서 reachability라는 개념을 사용한다. 어떤 객체에 유효한 참조가 있으면 'reachable'로, 없으면 'unreachable'로 구별하고, unreachable 객체를 가비지로 간주해 GC를 수행한다. 한 객체는 여러 다른 객체를 참조하고, 참조된 다른 객체들도 마찬가지로 또 다른 객체들을 참조할 수 있으므로 객체들은 참조 사슬을 이룬다. 이런 상황에서 유효한 참조 여부를 파악하려면 항상 유효한 최초의 참조가 있어야 하는데 이를 객체 참조의 root set이라고 한다. 힙에 있는 객체들에 대한 참조는 다음 4가지 종류 중 하나이다.

<pre>
- 힙 내의 다른 객체에 의한 참조
- Java 스택, 즉 Java 메서드 실행 시에 사용하는 지역 변수와 파라미터들에 의한 참조
- 네이티브 스택, 즉 JNI(Java Native Interface)에 의해 생성된 객체에 대한 참조
- 메서드 영역의 정적 변수에 의한 참조
</pre>

이들 중 힙 내의 다른 객체에 의한 참조를 제외한 나머지 3개가 root set으로, reachability를 판가름하는 기준이 된다.

### 2.3 Heap
가비지 컬렉터는 두 가지 가설 하에 만들어졌다.

<pre>
- 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.
- 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.
</pre>

가설의 장점을 살리기 위해 Heap을 다음과 같이 나누었다.

- Young  
  > 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
- Old  
  > 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.
- Permanent  
  > Method Area라고도 한다. 객체나 억류(intern)된 문자열 정보를 저장하는 곳이며, Old 영역에서 살아남은 객체가 영원히 남아 있는 곳은 절대 아니다. 이 영역에서 GC가 발생할 수도 있는데, 여기서 GC가 발생해도 Major GC의 횟수에 포함된다.

### 2.4 Minor GC
Young 영역은 3개의 영역으로 나뉜다.

<pre>
- Eden 영역
- Survivor 영역(2개)
</pre>

Survivor 영역이 2개이기 때문에 총 3개의 영역으로 나뉜다. 처리 절차는 다음과 같다.

<pre>
- 새로 생성한 대부분의 객체는 Eden 영역에 위치한다.
- Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
- Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.
- 하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동한다. 
- 그리고 가득 찬 Survivor 영역은 아무 데이터도 없는 상태로 된다.
- 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 된다.
</pre>

Survivor 영역 중 하나는 반드시 비어 있는 상태로 남아 있어야 한다. 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 시스템이 정상적인 상황이 아니라고 생각하면 된다.

### 2.5 Major GC
Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행하고, mark-sweep-compact라는 알고리즘을 사용한다. 이 알고리즘의 첫 단계는 Old 영역에 살아 있는 객체를 식별(Mark)하는 것이다. 그 다음에는 힙(heap)의 앞 부분부터 확인하여 살아 있는 것만 남긴다(Sweep). 마지막 단계에서는 각 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눈다(Compaction).

- Serial GC  
  > Serial GC는 적은 메모리와 CPU 코어 개수가 적을 때 적합한 방식이다.
- Parallel GC  
  > Parallel GC는 Serial GC와 기본적인 알고리즘은 같다. 그러나 Serial GC는 GC를 처리하는 스레드가 하나인 것에 비해, Parallel GC는 GC를 처리하는 쓰레드가 여러 개이다. 그렇기 때문에 Serial GC보다 빠른게 객체를 처리할 수 있다. Parallel GC는 메모리가 충분하고 코어의 개수가 많을 때 유리하다. Parallel GC는 Throughput GC라고도 부른다.
- G1 GC  
  > G1 GC는 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다. 즉, 지금까지 설명한 Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식이라고 이해하면 된다. G1 GC의 가장 큰 장점은 성능이다. 지금까지 설명한 어떤 GC 방식보다도 빠르다.

</br>
